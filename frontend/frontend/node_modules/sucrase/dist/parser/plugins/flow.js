"use strict";Object.defineProperty(exports, "__esModule", {value: true});/* eslint max-len: 0 */










var _index = require('../tokenizer/index');
var _keywords = require('../tokenizer/keywords');
var _types = require('../tokenizer/types');
var _base = require('../traverser/base');













var _expression = require('../traverser/expression');








var _statement = require('../traverser/statement');









var _util = require('../traverser/util');

function isMaybeDefaultImport(lookahead) {
  return (
    (lookahead.type === _types.TokenType.name || !!(lookahead.type & _types.TokenType.IS_KEYWORD)) &&
    lookahead.contextualKeyword !== _keywords.ContextualKeyword._from
  );
}

function flowParseTypeInitialiser(tok) {
  const oldIsType = _index.pushTypeContext.call(void 0, 0);
  _util.expect.call(void 0, tok || _types.TokenType.colon);
  flowParseType();
  _index.popTypeContext.call(void 0, oldIsType);
}

function flowParsePredicate() {
  _util.expect.call(void 0, _types.TokenType.modulo);
  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._checks);
  if (_index.eat.call(void 0, _types.TokenType.parenL)) {
    _expression.parseExpression.call(void 0, );
    _util.expect.call(void 0, _types.TokenType.parenR);
  }
}

function flowParseTypeAndPredicateInitialiser() {
  const oldIsType = _index.pushTypeContext.call(void 0, 0);
  _util.expect.call(void 0, _types.TokenType.colon);
  if (_index.match.call(void 0, _types.TokenType.modulo)) {
    flowParsePredicate();
  } else {
    flowParseType();
    if (_index.match.call(void 0, _types.TokenType.modulo)) {
      flowParsePredicate();
    }
  }
  _index.popTypeContext.call(void 0, oldIsType);
}

function flowParseDeclareClass() {
  _index.next.call(void 0, );
  flowParseInterfaceish(/* isClass */ true);
}

function flowParseDeclareFunction() {
  _index.next.call(void 0, );
  _expression.parseIdentifier.call(void 0, );

  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  _util.expect.call(void 0, _types.TokenType.parenL);
  flowParseFunctionTypeParams();
  _util.expect.call(void 0, _types.TokenType.parenR);

  flowParseTypeAndPredicateInitialiser();

  _util.semicolon.call(void 0, );
}

function flowParseDeclare() {
  if (_index.match.call(void 0, _types.TokenType._class)) {
    flowParseDeclareClass();
  } else if (_index.match.call(void 0, _types.TokenType._function)) {
    flowParseDeclareFunction();
  } else if (_index.match.call(void 0, _types.TokenType._var)) {
    flowParseDeclareVariable();
  } else if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._module)) {
    if (_index.eat.call(void 0, _types.TokenType.dot)) {
      flowParseDeclareModuleExports();
    } else {
      flowParseDeclareModule();
    }
  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._type)) {
    flowParseDeclareTypeAlias();
  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._opaque)) {
    flowParseDeclareOpaqueType();
  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._interface)) {
    flowParseDeclareInterface();
  } else if (_index.match.call(void 0, _types.TokenType._export)) {
    flowParseDeclareExportDeclaration();
  } else {
    _util.unexpected.call(void 0, );
  }
}

function flowParseDeclareVariable() {
  _index.next.call(void 0, );
  flowParseTypeAnnotatableIdentifier();
  _util.semicolon.call(void 0, );
}

function flowParseDeclareModule() {
  if (_index.match.call(void 0, _types.TokenType.string)) {
    _expression.parseExprAtom.call(void 0, );
  } else {
    _expression.parseIdentifier.call(void 0, );
  }

  _util.expect.call(void 0, _types.TokenType.braceL);
  while (!_index.match.call(void 0, _types.TokenType.braceR) && !_base.state.error) {
    if (_index.match.call(void 0, _types.TokenType._import)) {
      _index.next.call(void 0, );
      _statement.parseImport.call(void 0, );
    } else {
      _util.unexpected.call(void 0, );
    }
  }
  _util.expect.call(void 0, _types.TokenType.braceR);
}

function flowParseDeclareExportDeclaration() {
  _util.expect.call(void 0, _types.TokenType._export);

  if (_index.eat.call(void 0, _types.TokenType._default)) {
    if (_index.match.call(void 0, _types.TokenType._function) || _index.match.call(void 0, _types.TokenType._class)) {
      // declare export default class ...
      // declare export default function ...
      flowParseDeclare();
    } else {
      // declare export default [type];
      flowParseType();
      _util.semicolon.call(void 0, );
    }
  } else if (
  